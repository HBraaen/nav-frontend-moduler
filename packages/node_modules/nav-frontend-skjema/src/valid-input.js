import React, { Component } from 'react';
import PT from 'prop-types';
// import classNames from 'classnames';

import { Validator } from 'nav-frontend-js-utils';
import Input from './input';
import Textarea from './textarea';
import Select from './select';
import { skjemaelementFeilmeldingShape } from './skjemaelement-feilmelding';

class ValidInput extends Component {

    constructor(props) {
        super(props);

        this.state = {
            tests: [],
            valid: true
        };

        this.validators = [];
        this.supportedInputTextTypes = ['text', 'email', 'date', 'regex'];
        this.supportedInputNumberTypes = ['number', 'tlf', 'fnr', 'accountnr', 'orgnr'];

        this.hasValidateCallback = this.props.onValidate && typeof this.props.onValidate === 'function';
        this.hasCustomOnChange = this.props.onChange && typeof this.props.onChange === 'function';
        this.hasCustomOnBlur = this.props.onBlur && typeof this.props.onBlur === 'function';

        this.onChange = this.onChange.bind(this);
        this.onBlur = this.onBlur.bind(this);
    }

    componentDidMount() {
        // Initialize Validator with input node
        this.validator = new Validator(this.element);

        // Add appropriate default validator functions based on input type and other props
        const type = this.props.type;

        if (!this.props.optional) {
            this.validators.push(() => ({
                type: 'hasValue',
                verdict: this.validator.hasValue()
            }));
        }

        // Might be needed for <IE10 support where type="number" must be type="text"
        if (this.supportedInputNumberTypes.some((t) => t === type)) {
            this.validators.push(() => ({
                type: 'isNumeric',
                verdict: this.validator.isNumeric()
            }));
        }

        if (type === 'number' || type === 'select') {
            if (this.props.min && this.props.max) {
                this.validators.push(() => ({
                    type: 'isInRange',
                    verdict: this.validator.isInRange(parseInt(this.props.min, 10), parseInt(this.props.max, 10))
                }));
            } else if (this.props.min) {
                this.validators.push(() => ({
                    type: 'isGreaterThan',
                    verdict: this.validator.isGT(parseInt(this.props.min, 10))
                }));
            } else if (this.props.max) {
                this.validators.push(() => ({
                    type: 'isLessThan',
                    verdict: this.validator.isLT(parseInt(this.props.max, 10))
                }));
            }
        }

        if (this.props.maxLength && this.props.minLength) {
            this.validators.push(() => ({
                type: 'hasLengthRange',
                verdict: this.validator.hasLengthRange(this.props.minLength, this.props.maxLength)
            }));
        } else if (this.props.maxLength) {
            this.validators.push(() => ({
                type: 'isShorterThan',
                verdict: this.validator.isShorterThan(this.props.maxLength)
            }));
        } else if (this.props.minLength) {
            this.validators.push(() => ({
                type: 'isLongerThan',
                verdict: this.validator.isLongerThan(this.props.maxLength)
            }));
        }

        if (type === 'email') {
            this.validators.push(() => ({
                type: 'isEmailFormat',
                verdict: this.validator.isEmailFormat('gi')
            }));
        }

        if (type === 'fnr') {
            this.validators.push(() => ({
                type: 'isBirthNumFormat',
                verdict: this.validator.isBirthNumFormat()
            }));
        }

        if (type === 'accountnr') {
            this.validators.push(() => ({
                type: 'isAccountNumFormat',
                verdict: this.validator.isAccountNumFormat()
            }));
        }

        if (type === 'orgnr') {
            this.validators.push(() => ({
                type: 'isOrgNumFormat',
                verdict: this.validator.isOrgNumFormat()
            }));
        }

        if (this.props.matchPattern && type !== 'number') {
            this.validators.push(() => ({
                type: 'pattern',
                verdict: this.validator.matchesPattern(this.props.matchPattern, 'gi')
            }));
        }

        // If there is a custom validation function defined, add it to the validators array
        if (this.props.custom && typeof this.props.custom === 'function') {
            this.validators.push(() => ({
                type: 'custom',
                verdict: this.props.custom(this.element.value)
            }));
        }
    }

    onChange(e) {
        if (this.props.validateOnChange) {
            this.validate();
        }
        if (this.hasCustomOnChange) {
            this.props.onChange(e);
        }
    }

    onBlur(e) {
        if (this.props.validateOnBlur) {
            this.validate();
        }
        if (this.hasCustomOnBlur) {
            this.props.onBlur(e);
        }
    }

    getFirstFailedVerdict() {
        return this.state.tests.find((test) => !test.verdict);
    }

    isValid() {
        return this.state.valid;
    }

    validate() {
        const result = this.runValidation();
        this.props.onValidate(result);
    }

    runValidation() {
        let valid = true;
        const testsCopy = this.validators.map((validator) => {
            const validatorResult = validator();
            if (!validatorResult.verdict) valid = false;
            return validatorResult;
        });

        this.setState({
            tests: testsCopy.slice(),
            valid
        });

        return {
            name: this.props.name,
            tests: testsCopy.slice(),
            valid
        };
    }

    render() {
        const {
            onValidate, onChange, onBlur, validateOnChange, validateOnBlur, type, // eslint-disable-line no-unused-vars
            matchPattern, component, optional, feil, ...other // eslint-disable-line no-unused-vars
        } = this.props;

        const failedVerdict = (!this.state.valid) ? { feilmelding: this.getFirstFailedVerdict().type } : undefined;

        if (this.supportedInputTextTypes.some((t) => t === type)) {
            return (
                <Input
                    inputRef={(node) => { this.element = node; }}
                    onChange={this.onChange}
                    onBlur={this.onBlur}
                    feil={feil || failedVerdict}
                    {...other}
                />
            );
        } else if (this.supportedInputNumberTypes.some((t) => t === type)) {
            return (
                <Input
                    inputRef={(node) => { this.element = node; }}
                    onChange={this.onChange}
                    onBlur={this.onBlur}
                    feil={feil || failedVerdict}
                    type="number"
                    {...other}
                />
            );
        } else if (type === 'textarea') {
            return (
                <Textarea
                    textareaRef={(node) => { this.element = node; }}
                    onChange={this.onChange}
                    onBlur={this.onBlur}
                    feil={feil || failedVerdict}
                    {...other}
                />
            );
        } else if (type === 'select') {
            return (
                <Select
                    selectRef={(node) => { this.element = node; }}
                    onChange={this.onChange}
                    onBlur={this.onBlur}
                    feil={feil || failedVerdict}
                    {...other}
                >
                    {this.props.children}
                </Select>
            );
        }

        return 'Unsupported input type "' + type + '"'; // eslint-disable-line prefer-template
    }
}

ValidInput.propTypes = {
    onValidate: PT.func,
    onChange: PT.func,
    onBlur: PT.func,
    type: PT.oneOf(
        [
            'text', 'email', 'tlf', 'date', 'number', 'fnr', 'accountnr', 'orgnr', 'regex',
            'textarea', 'select', 'radiogroup', 'checkbox', 'checkbox-group'
        ]
    ).isRequired,
    optional: PT.bool,
    min: PT.number,
    max: PT.number,
    maxLength: PT.number,
    minLength: PT.number,
    matchPattern: PT.object, // eslint-disable-line react/forbid-prop-types
    custom: PT.func,
    name: PT.string.isRequired,
    component: PT.oneOf([Input, Textarea, Select]),
    feil: skjemaelementFeilmeldingShape,
    validateOnBlur: PT.bool,
    validateOnChange: PT.bool,
    children: PT.node
};

ValidInput.defaultProps = {
    onValidate: undefined,
    onChange: undefined,
    onBlur: undefined,
    optional: false,
    min: undefined,
    max: undefined,
    maxLength: undefined,
    minLength: undefined,
    matchPattern: undefined,
    custom: undefined,
    component: undefined,
    feil: undefined,
    validateOnBlur: true,
    validateOnChange: true,
    children: undefined
};

export default ValidInput;
